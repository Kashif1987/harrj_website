{"version":3,"sources":["../node_modules/react-toastify/node_modules/react-transition-group/esm/config.js","../node_modules/react-toastify/node_modules/react-transition-group/esm/TransitionGroupContext.js","../node_modules/react-toastify/node_modules/react-transition-group/esm/Transition.js","../node_modules/clsx/dist/clsx.m.js","../../src/utils/propValidator.ts","../../src/utils/constant.ts","../../src/utils/cssTransition.tsx","../../src/utils/collapseToast.ts","../../src/core/eventManager.ts","../../src/hooks/useKeeper.ts","../../src/hooks/toastContainerReducer.ts","../../src/hooks/useToastContainer.ts","../../src/hooks/useToast.ts","../../src/components/CloseButton.tsx","../../src/components/ProgressBar.tsx","../../src/components/Toast.tsx","../../src/components/Transitions.tsx","../../src/components/ToastPositioner.tsx","../../src/components/ToastContainer.tsx","../../src/core/toast.tsx"],"names":["React","createContext","Transition","_React$Component","props","context","_this","call","this","initialStatus","appear","isMounting","enter","appearStatus","in","unmountOnExit","mountOnEnter","state","status","nextCallback","_inheritsLoose","getDerivedStateFromProps","_ref","prevState","_proto","prototype","componentDidMount","updateStatus","componentDidUpdate","prevProps","nextStatus","componentWillUnmount","cancelNextCallback","getTimeouts","exit","timeout","undefined","mounting","performEnter","performExit","setState","_this2","appearing","_ref2","nodeRef","ReactDOM","findDOMNode","maybeNode","maybeAppearing","timeouts","enterTimeout","config","safeSetState","onEntered","onEnter","onEntering","onTransitionEnd","_this3","onExit","onExiting","onExited","cancel","nextState","callback","setNextCallback","_this4","active","event","handler","node","current","doesNotHaveTimeoutOrListener","addEndListener","_ref3","maybeNextCallback","setTimeout","render","_this$props","children","childProps","_objectWithoutPropertiesLoose","createElement","TransitionGroupContext","Provider","value","cloneElement","Children","only","Component","noop","contextType","propTypes","defaultProps","UNMOUNTED","EXITED","ENTERING","ENTERED","EXITING","toVal","mix","k","y","str","Array","isArray","length","tmp","x","i","arguments","isNum","v","isNaN","isBool","isStr","isFn","parseClassName","hasToastId","toastId","canUseDom","window","document","canBeRendered","content","isValidElement","POSITION","TOP_LEFT","TOP_RIGHT","TOP_CENTER","BOTTOM_LEFT","BOTTOM_RIGHT","BOTTOM_CENTER","TYPE","INFO","SUCCESS","WARNING","ERROR","DEFAULT","DARK","cssTransition","enterDuration","exitDuration","duration","_ref$duration","appendPosition","_ref$appendPosition","collapse","_ref$collapse","collapseDuration","_ref$collapseDuration","position","preventExitTransition","done","enterClassName","exitClassName","removeEventListener","height","scrollHeight","style","requestAnimationFrame","minHeight","transition","padding","margin","collapseToast","Object","assign","classList","add","animationFillMode","animationDuration","remove","removeProperty","addEventListener","eventManager","list","Map","emitQueue","on","has","set","get","push","off","cb","filter","cancelEmit","timers","forEach","timer","clearTimeout","emit","args","_len","_key","apply","useKeeper","arg","refresh","ref","useRef","useEffect","reducer","action","type","concat","id","staleId","useToastContainer","forceUpdate","useReducer","toast","_useReducer2","dispatch","containerRef","toastCount","queue","collection","instance","toastKey","displayedToast","containerId","isToastActive","getToast","indexOf","clearWaitingQueue","limit","_instance$props","enableMultiContainer","removeToast","queueLen","freeSlot","dequeueToast","toDequeue","shift","toastContent","_queue$shift","toastProps","appendToast","buildToast","delay","options","updateId","isNotValid","closeToast","isNotAnUpdate","toastAutoClose","containerAutoClose","key","closeButton","rtl","className","toastClassName","bodyClassName","toastStyle","bodyStyle","onClick","pauseOnHover","pauseOnFocusLoss","draggable","draggablePercent","closeOnClick","progressClassName","progressStyle","autoClose","hideProgressBar","progress","role","deleteToast","removeFromCollection","onOpen","onClose","getToastToRender","toastToRender","toastList","newestOnTop","keys","reverse","_toast","map","p","getX","e","targetTouches","clientX","useToast","useState","isRunning","_useState","setIsRunning","_useState2","setPreventExitTransition","toastRef","drag","start","deltaX","removalDistance","canCloseOnClick","canDrag","boundingRect","syncProps","onDragStart","getBoundingClientRect","nativeEvent","offsetWidth","onDragTransitionEnd","_drag$boundingRect","top","bottom","left","right","pauseToast","playToast","onDragMove","preventDefault","clientY","getY","transform","opacity","Math","abs","onDragEnd","eventHandlers","onMouseDown","onTouchStart","onMouseUp","onTouchEnd","onMouseEnter","onMouseLeave","CloseButton","ariaLabel","_ref$ariaLabel","stopPropagation","viewBox","fillRule","d","ProgressBar","hide","userStyle","controlledProgress","isIn","_extends","animationPlayState","defaultClassArr","classNames","defaultClassName","cx","animationEvent","_animationEvent","Toast","_useToast","cssClasses","renderCloseButton","Bounce","ToastPositioner","rest","child","ToastContainer","_useToastContainer","swag","_cx","_cx2","pointerEvents","latestInstance","containerDomNode","containerConfig","containers","lazy","isAnyContainerMounted","size","container","getContainer","generateToastId","random","toString","Date","now","substr","getToastId","dispatchToast","body","appendChild","mergeOptions","success","info","error","warning","dark","warn","dismiss","params","isActive","update","oldOptions","oldContent","nextOptions","onChange","configure","containerInstance","item","removeChild"],"mappings":"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","file":"static/js/0.2427a151.chunk.js","sourcesContent":["export default {\n  disabled: false\n};","import React from 'react';\nexport default React.createContext(null);","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport config from './config';\nimport { timeoutsShape } from './utils/PropTypes';\nimport TransitionGroupContext from './TransitionGroupContext';\nexport var UNMOUNTED = 'unmounted';\nexport var EXITED = 'exited';\nexport var ENTERING = 'entering';\nexport var ENTERED = 'entered';\nexport var EXITING = 'exiting';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * ---\n *\n * **Note**: `Transition` is a platform-agnostic base component. If you're using\n * transitions in CSS, you'll probably want to use\n * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)\n * instead. It inherits all the features of `Transition`, but contains\n * additional features necessary to play nice with CSS transitions (hence the\n * name of the component).\n *\n * ---\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the\n * components. It's up to you to give meaning and effect to those states. For\n * example we can add styles to a component when it enters or exits:\n *\n * ```jsx\n * import { Transition } from 'react-transition-group';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 1 },\n *   entered:  { opacity: 1 },\n *   exiting:  { opacity: 0 },\n *   exited:  { opacity: 0 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {state => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * There are 4 main states a Transition can be in:\n *  - `'entering'`\n *  - `'entered'`\n *  - `'exiting'`\n *  - `'exited'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component\n * begins the \"Enter\" stage. During this stage, the component will shift from\n * its current transition state, to `'entering'` for the duration of the\n * transition and then to the `'entered'` stage once it's complete. Let's take\n * the following example (we'll use the\n * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <Transition in={inProp} timeout={500}>\n *         {state => (\n *           // ...\n *         )}\n *       </Transition>\n *       <button onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state\n * and stay there for 500ms (the value of `timeout`) before it finally switches\n * to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from\n * `'exiting'` to `'exited'`.\n */\n\nvar Transition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Transition, _React$Component);\n\n  function Transition(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  } // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n  //   return { nextStatus }\n  // }\n  ;\n\n  var _proto = Transition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit, enter, appear;\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter; // TODO: remove fallback for next major\n\n      appear = timeout.appear !== undefined ? timeout.appear : enter;\n    }\n\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(mounting);\n      } else {\n        this.performExit();\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  _proto.performEnter = function performEnter(mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var appearing = this.context ? this.context.isMounting : mounting;\n\n    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing],\n        maybeNode = _ref2[0],\n        maybeAppearing = _ref2[1];\n\n    var timeouts = this.getTimeouts();\n    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter || config.disabled) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onEnter(maybeNode, maybeAppearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(maybeNode, maybeAppearing);\n\n      _this2.onTransitionEnd(enterTimeout, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(maybeNode, maybeAppearing);\n        });\n      });\n    });\n  };\n\n  _proto.performExit = function performExit() {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts();\n    var maybeNode = this.props.nodeRef ? undefined : ReactDOM.findDOMNode(this); // no exit animation skip right to EXITED\n\n    if (!exit || config.disabled) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onExit(maybeNode);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(maybeNode);\n\n      _this3.onTransitionEnd(timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(maybeNode);\n        });\n      });\n    });\n  };\n\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {\n    this.setNextCallback(handler);\n    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n\n    if (!node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n\n    if (this.props.addEndListener) {\n      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],\n          maybeNode = _ref3[0],\n          maybeNextCallback = _ref3[1];\n\n      this.props.addEndListener(maybeNode, maybeNextCallback);\n    }\n\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n\n  _proto.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        _in = _this$props.in,\n        _mountOnEnter = _this$props.mountOnEnter,\n        _unmountOnExit = _this$props.unmountOnExit,\n        _appear = _this$props.appear,\n        _enter = _this$props.enter,\n        _exit = _this$props.exit,\n        _timeout = _this$props.timeout,\n        _addEndListener = _this$props.addEndListener,\n        _onEnter = _this$props.onEnter,\n        _onEntering = _this$props.onEntering,\n        _onEntered = _this$props.onEntered,\n        _onExit = _this$props.onExit,\n        _onExiting = _this$props.onExiting,\n        _onExited = _this$props.onExited,\n        _nodeRef = _this$props.nodeRef,\n        childProps = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"in\", \"mountOnEnter\", \"unmountOnExit\", \"appear\", \"enter\", \"exit\", \"timeout\", \"addEndListener\", \"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\", \"nodeRef\"]);\n\n    return (\n      /*#__PURE__*/\n      // allows for nested Transitions\n      React.createElement(TransitionGroupContext.Provider, {\n        value: null\n      }, typeof children === 'function' ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))\n    );\n  };\n\n  return Transition;\n}(React.Component);\n\nTransition.contextType = TransitionGroupContext;\nTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A React reference to DOM element that need to transition:\n   * https://stackoverflow.com/a/51127130/4671932\n   *\n   *   - When `nodeRef` prop is used, `node` is not passed to callback functions\n   *      (e.g. `onEnter`) because user already has direct access to the node.\n   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new\n   *     `nodeRef` need to be provided to `Transition` with changed `key` prop\n   *     (see\n   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).\n   */\n  nodeRef: PropTypes.shape({\n    current: typeof Element === 'undefined' ? PropTypes.any : function (propValue, key, componentName, location, propFullName, secret) {\n      var value = propValue[key];\n      return PropTypes.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);\n    }\n  }),\n\n  /**\n   * A `function` child can be used instead of a React element. This function is\n   * called with the current transition status (`'entering'`, `'entered'`,\n   * `'exiting'`, `'exited'`), which can be used to apply context\n   * specific props to a component.\n   *\n   * ```jsx\n   * <Transition in={this.state.in} timeout={150}>\n   *   {state => (\n   *     <MyComponent className={`fade fade-${state}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,\n\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: PropTypes.bool,\n\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: PropTypes.bool,\n\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: PropTypes.bool,\n\n  /**\n   * By default the child component does not perform the enter transition when\n   * it first mounts, regardless of the value of `in`. If you want this\n   * behavior, set both `appear` and `in` to `true`.\n   *\n   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop\n   * > only adds an additional enter transition. However, in the\n   * > `<CSSTransition>` component that first enter transition does result in\n   * > additional `.appear-*` classes, that way you can choose to style it\n   * > differently.\n   */\n  appear: PropTypes.bool,\n\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: PropTypes.bool,\n\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: PropTypes.bool,\n\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided.\n   *\n   * You may specify a single timeout for all transitions:\n   *\n   * ```jsx\n   * timeout={500}\n   * ```\n   *\n   * or individually:\n   *\n   * ```jsx\n   * timeout={{\n   *  appear: 500,\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * - `appear` defaults to the value of `enter`\n   * - `enter` defaults to `0`\n   * - `exit` defaults to `0`\n   *\n   * @type {number | { enter?: number, exit?: number, appear?: number }}\n   */\n  timeout: function timeout(props) {\n    var pt = timeoutsShape;\n    if (!props.addEndListener) pt = pt.isRequired;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return pt.apply(void 0, [props].concat(args));\n  },\n\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. Timeouts are still used as a fallback if provided.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: PropTypes.func,\n\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: PropTypes.func\n} : {}; // Name the function so it is clearer in the documentation\n\nfunction noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\nTransition.UNMOUNTED = UNMOUNTED;\nTransition.EXITED = EXITED;\nTransition.ENTERING = ENTERING;\nTransition.ENTERED = ENTERED;\nTransition.EXITING = EXITING;\nexport default Transition;","function toVal(mix) {\n\tvar k, y, str='';\n\n\tif (typeof mix === 'string' || typeof mix === 'number') {\n\t\tstr += mix;\n\t} else if (typeof mix === 'object') {\n\t\tif (Array.isArray(mix)) {\n\t\t\tfor (k=0; k < mix.length; k++) {\n\t\t\t\tif (mix[k]) {\n\t\t\t\t\tif (y = toVal(mix[k])) {\n\t\t\t\t\t\tstr && (str += ' ');\n\t\t\t\t\t\tstr += y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (k in mix) {\n\t\t\t\tif (mix[k]) {\n\t\t\t\t\tstr && (str += ' ');\n\t\t\t\t\tstr += k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn str;\n}\n\nexport default function () {\n\tvar i=0, tmp, x, str='';\n\twhile (i < arguments.length) {\n\t\tif (tmp = arguments[i++]) {\n\t\t\tif (x = toVal(tmp)) {\n\t\t\t\tstr && (str += ' ');\n\t\t\t\tstr += x\n\t\t\t}\n\t\t}\n\t}\n\treturn str;\n}\n","import { isValidElement } from 'react';\n\nimport { Id } from '../types';\n\nexport function isNum(v: any): v is Number {\n  return typeof v === 'number' && !isNaN(v);\n}\n\nexport function isBool(v: any): v is Boolean {\n  return typeof v === 'boolean';\n}\n\nexport function isStr(v: any): v is String {\n  return typeof v === 'string';\n}\n\nexport function isFn(v: any): v is Function {\n  return typeof v === 'function';\n}\n\nexport function parseClassName(v: any) {\n  return isStr(v) || isFn(v) ? v : null;\n}\n\nexport function objectValues<T>(obj: Record<string, T>) {\n  return Object.keys(obj).map(key => obj[key]);\n}\n\nexport function hasToastId(toastId?: Id) {\n  return toastId === 0 || toastId;\n}\n\nexport function getAutoCloseDelay(\n  toastAutoClose?: false | number,\n  containerAutoClose?: false | number\n) {\n  return toastAutoClose === false ||\n    (isNum(toastAutoClose) && toastAutoClose > 0)\n    ? toastAutoClose\n    : containerAutoClose;\n}\n\nexport const canUseDom = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\nexport function canBeRendered<T>(content: T): boolean {\n  return (\n    isValidElement(content) || isStr(content) || isFn(content) || isNum(content)\n  );\n}\n","import { ToastPosition, TypeOptions } from '../types';\n\ntype KeyOfPosition =\n  | 'TOP_LEFT'\n  | 'TOP_RIGHT'\n  | 'TOP_CENTER'\n  | 'BOTTOM_LEFT'\n  | 'BOTTOM_RIGHT'\n  | 'BOTTOM_CENTER';\n\ntype KeyOfType = 'INFO' | 'SUCCESS' | 'WARNING' | 'ERROR' | 'DEFAULT' | 'DARK';\n\nexport const POSITION: { [key in KeyOfPosition]: ToastPosition } = {\n  TOP_LEFT: 'top-left',\n  TOP_RIGHT: 'top-right',\n  TOP_CENTER: 'top-center',\n  BOTTOM_LEFT: 'bottom-left',\n  BOTTOM_RIGHT: 'bottom-right',\n  BOTTOM_CENTER: 'bottom-center'\n};\n\nexport const TYPE: { [key in KeyOfType]: TypeOptions } = {\n  INFO: 'info',\n  SUCCESS: 'success',\n  WARNING: 'warning',\n  ERROR: 'error',\n  DEFAULT: 'default',\n  DARK: 'dark'\n};\n\nexport const enum DEFAULT {\n  COLLAPSE_DURATION = 300,\n  DEBOUNCE_DURATION = 50,\n  CSS_NAMESPACE = 'Toastify'\n}\n","import * as React from 'react';\nimport { Transition } from 'react-transition-group';\nimport { ToastTransitionProps } from '../types';\n\nimport { collapseToast } from './collapseToast';\nimport { DEFAULT } from './constant';\n\nexport interface CSSTransitionProps {\n  /**\n   * Css class to apply when toast enter\n   */\n  enter: string;\n\n  /**\n   * Css class to apply when toast leave\n   */\n  exit: string;\n\n  /**\n   * Define the duration of the transition in ms\n   * You can also pass an array `[enterDuration, exitDuration]`\n   * `Default: 750`\n   */\n  duration?: number | [number, number];\n\n  /**\n   * Append current toast position to the classname.\n   * For instance `myclass--top-center`...\n   * `Default: false`\n   */\n  appendPosition?: boolean;\n\n  /**\n   * Collapse toast smoothly when animation end\n   * `Default: true`\n   */\n  collapse?: boolean;\n\n  /**\n   * Collapse transition duration\n   * `Default: 300`\n   */\n  collapseDuration?: number;\n}\n\nexport function cssTransition({\n  enter,\n  exit,\n  duration = 750,\n  appendPosition = false,\n  collapse = true,\n  collapseDuration = DEFAULT.COLLAPSE_DURATION\n}: CSSTransitionProps) {\n  let enterDuration: number, exitDuration: number;\n\n  if (Array.isArray(duration) && duration.length === 2) {\n    [enterDuration, exitDuration] = duration;\n  } else {\n    enterDuration = exitDuration = duration as number;\n  }\n\n  return function ToastTransition({\n    children,\n    position,\n    preventExitTransition,\n    done,\n    ...props\n  }: ToastTransitionProps) {\n    const enterClassName = appendPosition ? `${enter}--${position}` : enter;\n    const exitClassName = appendPosition ? `${exit}--${position}` : exit;\n\n    const onEnter = () => {\n      const node = props.nodeRef.current;\n      if (node) {\n        node.classList.add(enterClassName);\n        node.style.animationFillMode = 'forwards';\n        node.style.animationDuration = `${enterDuration}ms`;\n      }\n    };\n\n    const onEntered = () => {\n      const node = props.nodeRef.current;\n      if (node) {\n        node.classList.remove(enterClassName);\n        node.style.removeProperty('animationFillMode');\n        node.style.removeProperty('animationDuration');\n      }\n    };\n\n    const onExited = () => {\n      const node = props.nodeRef.current;\n\n      if (node) {\n        node.removeEventListener('animationend', onExited);\n        collapse ? collapseToast(node, done, collapseDuration) : done();\n      }\n    };\n\n    const onExit = () => {\n      const node = props.nodeRef.current;\n      if (node) {\n        node.classList.add(exitClassName);\n        node.style.animationFillMode = 'forwards';\n        node.style.animationDuration = `${exitDuration}ms`;\n        node.addEventListener('animationend', onExited);\n      }\n    };\n\n    return (\n      <Transition\n        {...props}\n        timeout={\n          preventExitTransition\n            ? collapse\n              ? collapseDuration\n              : DEFAULT.DEBOUNCE_DURATION\n            : {\n                enter: enterDuration,\n                exit: collapse\n                  ? exitDuration + collapseDuration\n                  : exitDuration + DEFAULT.DEBOUNCE_DURATION\n              }\n        }\n        onEnter={onEnter}\n        onEntered={onEntered}\n        onExit={preventExitTransition ? onExited : onExit}\n        unmountOnExit\n      >\n        {children}\n      </Transition>\n    );\n  };\n}\n","import { DEFAULT } from './constant';\n\n/**\n * Used to collapse toast after exit animation\n */\nexport function collapseToast(\n  node: HTMLElement,\n  done: () => void,\n  duration = DEFAULT.COLLAPSE_DURATION\n) {\n  const height = node.scrollHeight;\n  const style = node.style;\n\n  requestAnimationFrame(() => {\n    style.minHeight = 'initial';\n    style.height = height + 'px';\n    style.transition = `all ${duration}ms`;\n\n    requestAnimationFrame(() => {\n      style.height = '0';\n      style.padding = '0';\n      style.margin = '0';\n      setTimeout(() => done(), duration as number);\n    });\n  });\n}\n","import {\n  Id,\n  ToastContent,\n  ClearWaitingQueueParams,\n  NotValidatedToastProps\n} from '../types';\nimport { ContainerInstance } from '../hooks';\n\nexport const enum Event {\n  Show,\n  Clear,\n  DidMount,\n  WillUnmount,\n  Change,\n  ClearWaitingQueue\n}\n\ntype OnShowCallback = (\n  content: ToastContent,\n  options: NotValidatedToastProps\n) => void;\ntype OnClearCallback = (id?: Id) => void;\ntype OnClearWaitingQueue = (params: ClearWaitingQueueParams) => void;\ntype OnDidMountCallback = (containerInstance: ContainerInstance) => void;\ntype OnWillUnmountCallback = OnDidMountCallback;\nexport type OnChangeCallback = (\n  toast: number,\n  containerId?: number | string\n) => void;\ntype Callback =\n  | OnShowCallback\n  | OnClearCallback\n  | OnClearWaitingQueue\n  | OnDidMountCallback\n  | OnWillUnmountCallback\n  | OnChangeCallback;\ntype TimeoutId = ReturnType<typeof window.setTimeout>;\n\nexport interface EventManager {\n  list: Map<Event, Callback[]>;\n  emitQueue: Map<Event, TimeoutId[]>;\n  on(event: Event.Show, callback: OnShowCallback): EventManager;\n  on(event: Event.Clear, callback: OnClearCallback): EventManager;\n  on(\n    event: Event.ClearWaitingQueue,\n    callback: OnClearWaitingQueue\n  ): EventManager;\n  on(event: Event.DidMount, callback: OnDidMountCallback): EventManager;\n  on(event: Event.WillUnmount, callback: OnWillUnmountCallback): EventManager;\n  on(event: Event.Change, callback: OnChangeCallback): EventManager;\n  off(event: Event, callback?: Callback): EventManager;\n  cancelEmit(event: Event): EventManager;\n  emit(\n    event: Event.Show,\n    content: React.ReactNode,\n    options: NotValidatedToastProps\n  ): void;\n  emit(event: Event.Clear, id?: string | number): void;\n  emit(event: Event.ClearWaitingQueue, params: ClearWaitingQueueParams): void;\n  emit(event: Event.DidMount, containerInstance: ContainerInstance): void;\n  emit(event: Event.WillUnmount, containerInstance: ContainerInstance): void;\n  emit(event: Event.Change, toast: number, containerId?: number | string): void;\n}\n\nexport const eventManager: EventManager = {\n  list: new Map(),\n  emitQueue: new Map(),\n\n  on(event: Event, callback: Callback) {\n    this.list.has(event) || this.list.set(event, []);\n    this.list.get(event)!.push(callback);\n    return this;\n  },\n\n  off(event, callback) {\n    if (callback) {\n      const cb = this.list.get(event)!.filter(cb => cb !== callback);\n      this.list.set(event, cb);\n      return this;\n    }\n    this.list.delete(event);\n    return this;\n  },\n\n  cancelEmit(event) {\n    const timers = this.emitQueue.get(event);\n    if (timers) {\n      timers.forEach((timer: TimeoutId) => clearTimeout(timer));\n      this.emitQueue.delete(event);\n    }\n\n    return this;\n  },\n\n  /**\n   * Enqueue the event at the end of the call stack\n   * Doing so let the user call toast as follow:\n   * toast('1')\n   * toast('2')\n   * toast('3')\n   * Without setTimemout the code above will not work\n   */\n  emit(event: Event, ...args: any[]) {\n    this.list.has(event) &&\n      this.list.get(event)!.forEach((callback: Callback) => {\n        const timer = setTimeout(() => {\n          // @ts-ignore\n          callback(...args);\n        }, 0);\n\n        this.emitQueue.has(event) || this.emitQueue.set(event, []);\n        this.emitQueue.get(event)!.push(timer);\n      });\n  }\n};\n","import { useRef, useEffect } from 'react';\n\n/**\n * `useKeeper` is a helper around `useRef`.\n *\n * You don't need to access the `.current`property to get the value\n * If refresh is set to true. The ref will be updated every render\n */\nexport function useKeeper<T>(arg: T, refresh = false) {\n  const ref = useRef<T>(arg);\n\n  useEffect(() => {\n    if (refresh) ref.current = arg;\n  });\n\n  return ref.current;\n}\n","import { Id } from '../types';\n\nimport { hasToastId } from '../utils';\n\nexport type State = Array<Id>;\nexport type Action =\n  | { type: 'ADD'; toastId: Id; staleId?: Id }\n  | { type: 'REMOVE'; toastId?: Id };\n\nexport function reducer(state: State, action: Action) {\n  switch (action.type) {\n    case 'ADD':\n      return [...state, action.toastId].filter(id => id !== action.staleId);\n    case 'REMOVE':\n      return hasToastId(action.toastId)\n        ? state.filter(id => id !== action.toastId)\n        : [];\n  }\n}\n","import {\n  useEffect,\n  useRef,\n  useReducer,\n  cloneElement,\n  isValidElement\n} from 'react';\nimport {\n  parseClassName,\n  canBeRendered,\n  isBool,\n  isFn,\n  isNum,\n  isStr,\n  hasToastId,\n  getAutoCloseDelay\n} from '../utils';\nimport { eventManager, Event } from '../core/eventManager';\n\nimport {\n  Id,\n  ToastContainerProps,\n  ToastProps,\n  ToastContent,\n  Toast,\n  ToastPosition,\n  ClearWaitingQueueParams,\n  NotValidatedToastProps,\n  ToastTransition\n} from '../types';\nimport { useKeeper } from './useKeeper';\nimport { reducer } from './toastContainerReducer';\n\ntype CollectionItem = Record<Id, Toast>;\ntype ToastToRender = Partial<Record<ToastPosition, Toast[]>>;\n\ninterface QueuedToast {\n  toastContent: ToastContent;\n  toastProps: ToastProps;\n  staleId?: Id;\n}\n\nexport interface ContainerInstance {\n  toastKey: number;\n  displayedToast: number;\n  props: ToastContainerProps;\n  containerId?: Id | null;\n  isToastActive: (toastId: Id) => boolean;\n  getToast: (id: Id) => Toast | null;\n}\n\nexport function useToastContainer(props: ToastContainerProps) {\n  const [, forceUpdate] = useReducer(x => x + 1, 0);\n  const [toast, dispatch] = useReducer(reducer, []);\n  const containerRef = useRef(null);\n  let toastCount = useKeeper(0);\n  let queue = useKeeper<QueuedToast[]>([]);\n  const collection = useKeeper<CollectionItem>({});\n  const instance = useKeeper<ContainerInstance>({\n    toastKey: 1,\n    displayedToast: 0,\n    props,\n    containerId: null,\n    isToastActive: isToastActive,\n    getToast: id => collection[id] || null\n  });\n\n  useEffect(() => {\n    instance.containerId = props.containerId;\n    eventManager\n      .cancelEmit(Event.WillUnmount)\n      .on(Event.Show, buildToast)\n      .on(Event.Clear, toastId => containerRef.current && removeToast(toastId))\n      .on(Event.ClearWaitingQueue, clearWaitingQueue)\n      .emit(Event.DidMount, instance);\n\n    return () => eventManager.emit(Event.WillUnmount, instance);\n  }, []);\n\n  useEffect(() => {\n    instance.isToastActive = isToastActive;\n    instance.displayedToast = toast.length;\n    eventManager.emit(Event.Change, toast.length, props.containerId);\n  }, [toast]);\n\n  useEffect(() => {\n    instance.props = props;\n  });\n\n  function isToastActive(id: Id) {\n    return toast.indexOf(id) !== -1;\n  }\n\n  function clearWaitingQueue({ containerId }: ClearWaitingQueueParams) {\n    const { limit, enableMultiContainer } = instance.props;\n    if (\n      limit &&\n      (!containerId ||\n        (instance.containerId === containerId && enableMultiContainer))\n    ) {\n      toastCount -= queue.length;\n      queue = [];\n    }\n  }\n\n  function removeToast(toastId?: Id) {\n    const queueLen = queue.length;\n    toastCount = hasToastId(toastId)\n      ? toastCount - 1\n      : toastCount - instance.displayedToast;\n\n    if (toastCount < 0) toastCount = 0;\n\n    if (queueLen > 0) {\n      const freeSlot = hasToastId(toastId) ? 1 : instance.props.limit!;\n\n      if (queueLen === 1 || freeSlot === 1) {\n        instance.displayedToast++;\n        dequeueToast();\n      } else {\n        const toDequeue = freeSlot > queueLen ? queueLen : freeSlot;\n        instance.displayedToast = toDequeue;\n\n        for (let i = 0; i < toDequeue; i++) dequeueToast();\n      }\n    }\n    dispatch({ type: 'REMOVE', toastId });\n  }\n\n  function dequeueToast() {\n    const { toastContent, toastProps, staleId } = queue.shift() as QueuedToast;\n\n    // ensure that exit transition has been completed, hence the timeout\n    setTimeout(() => {\n      appendToast(toastContent, toastProps, staleId);\n    }, 500);\n  }\n\n  /**\n   * check if a container is attached to the dom\n   * check for multi-container, build only if associated\n   * check for duplicate toastId if no update\n   */\n  function isNotValid({\n    containerId,\n    toastId,\n    updateId\n  }: NotValidatedToastProps) {\n    return !containerRef.current ||\n      (instance.props.enableMultiContainer &&\n        containerId !== instance.props.containerId) ||\n      (instance.isToastActive(toastId) && updateId == null)\n      ? true\n      : false;\n  }\n\n  // this function and all the function called inside needs to rely on ref(`useKeeper`)\n  function buildToast(\n    content: ToastContent,\n    { delay, staleId, ...options }: NotValidatedToastProps\n  ) {\n    if (!canBeRendered(content) || isNotValid(options)) return;\n\n    const { toastId, updateId } = options;\n    const { props, isToastActive } = instance;\n    const closeToast = () => removeToast(toastId);\n    const isNotAnUpdate = !isToastActive(toastId);\n\n    if (isNotAnUpdate) toastCount++;\n\n    const toastProps: ToastProps = {\n      toastId,\n      updateId,\n      key: options.key || instance.toastKey++,\n      type: options.type,\n      closeToast: closeToast,\n      closeButton: options.closeButton,\n      rtl: props.rtl,\n      position: options.position || (props.position as ToastPosition),\n      transition: options.transition || (props.transition as ToastTransition),\n      className: parseClassName(options.className || props.toastClassName),\n      bodyClassName: parseClassName(\n        options.bodyClassName || props.bodyClassName\n      ),\n      style: options.style || props.toastStyle,\n      bodyStyle: options.bodyStyle || props.bodyStyle,\n      onClick: options.onClick || props.onClick,\n      pauseOnHover: isBool(options.pauseOnHover)\n        ? options.pauseOnHover\n        : props.pauseOnHover,\n      pauseOnFocusLoss: isBool(options.pauseOnFocusLoss)\n        ? options.pauseOnFocusLoss\n        : props.pauseOnFocusLoss,\n      draggable: isBool(options.draggable)\n        ? options.draggable\n        : props.draggable,\n      draggablePercent: isNum(options.draggablePercent)\n        ? options.draggablePercent\n        : (props.draggablePercent as number),\n      closeOnClick: isBool(options.closeOnClick)\n        ? options.closeOnClick\n        : props.closeOnClick,\n      progressClassName: parseClassName(\n        options.progressClassName || props.progressClassName\n      ),\n      progressStyle: options.progressStyle || props.progressStyle,\n      autoClose: getAutoCloseDelay(options.autoClose, props.autoClose),\n      hideProgressBar: isBool(options.hideProgressBar)\n        ? options.hideProgressBar\n        : props.hideProgressBar,\n      progress: options.progress,\n      role: isStr(options.role) ? options.role : props.role,\n      deleteToast() {\n        removeFromCollection(toastId);\n      }\n    };\n\n    if (isFn(options.onOpen)) toastProps.onOpen = options.onOpen;\n    if (isFn(options.onClose)) toastProps.onClose = options.onClose;\n\n    let closeButton = props.closeButton;\n\n    if (options.closeButton === false || canBeRendered(options.closeButton)) {\n      closeButton = options.closeButton;\n    } else if (options.closeButton === true) {\n      closeButton = canBeRendered(props.closeButton) ? props.closeButton : true;\n    }\n\n    toastProps.closeButton = closeButton;\n\n    let toastContent = content;\n\n    if (isValidElement(content) && !isStr(content.type)) {\n      toastContent = cloneElement(content, {\n        closeToast,\n        toastProps\n      });\n    } else if (isFn(content)) {\n      toastContent = content({ closeToast, toastProps });\n    }\n\n    // not handling limit + delay by design. Waiting for user feedback first\n    if (\n      props.limit &&\n      props.limit > 0 &&\n      toastCount > props.limit &&\n      isNotAnUpdate\n    ) {\n      queue.push({ toastContent, toastProps, staleId });\n    } else if (isNum(delay) && (delay as number) > 0) {\n      setTimeout(() => {\n        appendToast(toastContent, toastProps, staleId);\n      }, delay);\n    } else {\n      appendToast(toastContent, toastProps, staleId);\n    }\n  }\n\n  function appendToast(\n    content: ToastContent,\n    toastProps: ToastProps,\n    staleId?: Id\n  ) {\n    const { toastId } = toastProps;\n\n    collection[toastId] = {\n      content,\n      props: toastProps\n    };\n    dispatch({\n      type: 'ADD',\n      toastId,\n      staleId\n    });\n  }\n\n  function removeFromCollection(toastId: Id) {\n    delete collection[toastId];\n    forceUpdate();\n  }\n\n  function getToastToRender<T>(\n    cb: (position: ToastPosition, toastList: Toast[]) => T\n  ) {\n    const toastToRender: ToastToRender = {};\n    const toastList = props.newestOnTop\n      ? Object.keys(collection).reverse()\n      : Object.keys(collection);\n\n    for (let i = 0; i < toastList.length; i++) {\n      const toast = collection[toastList[i]];\n      const { position } = toast.props;\n      toastToRender[position] || (toastToRender[position] = []);\n\n      toastToRender[position]!.push(toast);\n    }\n\n    return (Object.keys(toastToRender) as Array<ToastPosition>).map(p =>\n      cb(p, toastToRender[p]!)\n    );\n  }\n\n  return {\n    getToastToRender,\n    collection,\n    containerRef,\n    isToastActive\n  };\n}\n","import {\n  useState,\n  useRef,\n  useEffect,\n  isValidElement,\n  DOMAttributes\n} from 'react';\n\nimport { isFn } from '../utils';\nimport { ToastProps } from '../types';\nimport { useKeeper } from './useKeeper';\n\ninterface Draggable {\n  start: number;\n  x: number;\n  y: number;\n  deltaX: number;\n  removalDistance: number;\n  canCloseOnClick: boolean;\n  canDrag: boolean;\n  boundingRect: DOMRect | null;\n}\n\ntype DragEvent = MouseEvent & TouchEvent;\n\nfunction getX(e: DragEvent) {\n  return e.targetTouches && e.targetTouches.length >= 1\n    ? e.targetTouches[0].clientX\n    : e.clientX;\n}\n\nfunction getY(e: DragEvent) {\n  return e.targetTouches && e.targetTouches.length >= 1\n    ? e.targetTouches[0].clientY\n    : e.clientY;\n}\n\nexport function useToast(props: ToastProps) {\n  const [isRunning, setIsRunning] = useState(true);\n  const [preventExitTransition, setPreventExitTransition] = useState(false);\n  const toastRef = useRef<HTMLDivElement>(null);\n  const drag = useKeeper<Draggable>({\n    start: 0,\n    x: 0,\n    y: 0,\n    deltaX: 0,\n    removalDistance: 0,\n    canCloseOnClick: true,\n    canDrag: false,\n    boundingRect: null\n  });\n  const syncProps = useKeeper(props, true);\n  const { autoClose, pauseOnHover, closeToast, onClick, closeOnClick } = props;\n\n  useEffect(() => {\n    if (isFn(props.onOpen))\n      props.onOpen(isValidElement(props.children) && props.children.props);\n\n    return () => {\n      if (isFn(syncProps.onClose))\n        syncProps.onClose(\n          isValidElement(syncProps.children) && syncProps.children.props\n        );\n    };\n  }, []);\n\n  useEffect(() => {\n    props.draggable && bindDragEvents();\n    return () => {\n      props.draggable && unbindDragEvents();\n    };\n  }, [props.draggable]);\n\n  useEffect(() => {\n    props.pauseOnFocusLoss && bindFocusEvents();\n    return () => {\n      props.pauseOnFocusLoss && unbindFocusEvents();\n    };\n  }, [props.pauseOnFocusLoss]);\n\n  function onDragStart(\n    e: React.MouseEvent<HTMLElement, MouseEvent> | React.TouchEvent<HTMLElement>\n  ) {\n    const toast = toastRef.current!;\n    drag.canCloseOnClick = true;\n    drag.canDrag = true;\n    drag.boundingRect = toast.getBoundingClientRect();\n    toast.style.transition = '';\n    drag.start = drag.x = getX(e.nativeEvent as DragEvent);\n    drag.removalDistance = toast.offsetWidth * (props.draggablePercent / 100);\n  }\n\n  function onDragTransitionEnd() {\n    if (drag.boundingRect) {\n      const { top, bottom, left, right } = drag.boundingRect;\n\n      if (\n        props.pauseOnHover &&\n        drag.x >= left &&\n        drag.x <= right &&\n        drag.y >= top &&\n        drag.y <= bottom\n      ) {\n        pauseToast();\n      } else {\n        playToast();\n      }\n    }\n  }\n\n  function playToast() {\n    setIsRunning(true);\n  }\n\n  function pauseToast() {\n    setIsRunning(false);\n  }\n\n  function bindFocusEvents() {\n    window.addEventListener('focus', playToast);\n    window.addEventListener('blur', pauseToast);\n  }\n\n  function unbindFocusEvents() {\n    window.removeEventListener('focus', playToast);\n    window.removeEventListener('blur', pauseToast);\n  }\n\n  function bindDragEvents() {\n    document.addEventListener('mousemove', onDragMove);\n    document.addEventListener('mouseup', onDragEnd);\n\n    document.addEventListener('touchmove', onDragMove);\n    document.addEventListener('touchend', onDragEnd);\n  }\n\n  function unbindDragEvents() {\n    document.removeEventListener('mousemove', onDragMove);\n    document.removeEventListener('mouseup', onDragEnd);\n\n    document.removeEventListener('touchmove', onDragMove);\n    document.removeEventListener('touchend', onDragEnd);\n  }\n\n  function onDragMove(e: MouseEvent | TouchEvent) {\n    e.preventDefault();\n\n    const toast = toastRef.current!;\n\n    if (drag.canDrag) {\n      if (isRunning) pauseToast();\n\n      drag.x = getX(e as DragEvent);\n      drag.deltaX = drag.x - drag.start;\n      drag.y = getY(e as DragEvent);\n\n      // prevent false positif during a toast click\n      if (drag.start !== drag.x) drag.canCloseOnClick = false;\n\n      toast.style.transform = `translateX(${drag.deltaX}px)`;\n      toast.style.opacity = `${1 -\n        Math.abs(drag.deltaX / drag.removalDistance)}`;\n    }\n  }\n\n  function onDragEnd() {\n    const toast = toastRef.current!;\n    if (drag.canDrag) {\n      drag.canDrag = false;\n\n      if (Math.abs(drag.deltaX) > drag.removalDistance) {\n        setPreventExitTransition(true);\n        props.closeToast();\n        return;\n      }\n\n      toast.style.transition = 'transform 0.2s, opacity 0.2s';\n      toast.style.transform = 'translateX(0)';\n      toast.style.opacity = '1';\n    }\n  }\n\n  const eventHandlers: DOMAttributes<HTMLElement> = {\n    onMouseDown: onDragStart,\n    onTouchStart: onDragStart,\n    onMouseUp: onDragTransitionEnd,\n    onTouchEnd: onDragTransitionEnd\n  };\n\n  if (autoClose && pauseOnHover) {\n    eventHandlers.onMouseEnter = pauseToast;\n    eventHandlers.onMouseLeave = playToast;\n  }\n\n  // prevent toast from closing when user drags the toast\n  if (closeOnClick) {\n    eventHandlers.onClick = (e: React.MouseEvent) => {\n      onClick && onClick(e);\n      drag.canCloseOnClick && closeToast();\n    };\n  }\n\n  return {\n    playToast,\n    pauseToast,\n    isRunning,\n    preventExitTransition,\n    toastRef,\n    eventHandlers\n  };\n}\n","import * as React from 'react';\nimport { DEFAULT } from '../utils';\nimport { TypeOptions } from '../types';\n\nexport interface CloseButtonProps {\n  closeToast: (e: React.MouseEvent<HTMLElement>) => void;\n  type: TypeOptions;\n  ariaLabel?: string;\n}\n\nexport function CloseButton({\n  closeToast,\n  type,\n  ariaLabel = 'close'\n}: CloseButtonProps) {\n  return (\n    <button\n      className={`${DEFAULT.CSS_NAMESPACE}__close-button ${DEFAULT.CSS_NAMESPACE}__close-button--${type}`}\n      type=\"button\"\n      onClick={e => {\n        e.stopPropagation();\n        closeToast(e);\n      }}\n      aria-label={ariaLabel}\n    >\n      <svg aria-hidden=\"true\" viewBox=\"0 0 14 16\">\n        <path\n          fillRule=\"evenodd\"\n          d=\"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z\"\n        />\n      </svg>\n    </button>\n  );\n}\n","import * as React from 'react';\nimport cx from 'clsx';\n\nimport { TYPE, DEFAULT, isFn } from './../utils';\nimport { TypeOptions, ToastClassName } from '../types';\n\nexport interface ProgressBarProps {\n  /**\n   * The animation delay which determine when to close the toast\n   */\n  delay: number;\n\n  /**\n   * Whether or not the animation is running or paused\n   */\n  isRunning: boolean;\n\n  /**\n   * Func to close the current toast\n   */\n  closeToast: () => void;\n\n  /**\n   * Optional type : info, success ...\n   */\n  type: TypeOptions;\n\n  /**\n   * Hide or not the progress bar\n   */\n  hide?: boolean;\n\n  /**\n   * Optionnal className\n   */\n  className?: ToastClassName;\n\n  /**\n   * Optionnal inline style\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * Tell wether or not controlled progress bar is used\n   */\n  controlledProgress?: boolean;\n\n  /**\n   * Controlled progress value\n   */\n  progress?: number | string;\n\n  /**\n   * Support rtl content\n   */\n  rtl?: boolean;\n\n  /**\n   * Tell if the component is visible on screen or not\n   */\n  isIn?: boolean;\n}\n\nexport function ProgressBar({\n  delay,\n  isRunning,\n  closeToast,\n  type,\n  hide,\n  className,\n  style: userStyle,\n  controlledProgress,\n  progress,\n  rtl,\n  isIn\n}: ProgressBarProps) {\n  const style: React.CSSProperties = {\n    ...userStyle,\n    animationDuration: `${delay}ms`,\n    animationPlayState: isRunning ? 'running' : 'paused',\n    opacity: hide ? 0 : 1\n  };\n\n  if (controlledProgress) style.transform = `scaleX(${progress})`;\n  const defaultClassArr = [\n    `${DEFAULT.CSS_NAMESPACE}__progress-bar`,\n    controlledProgress\n      ? `${DEFAULT.CSS_NAMESPACE}__progress-bar--controlled`\n      : `${DEFAULT.CSS_NAMESPACE}__progress-bar--animated`,\n    `${DEFAULT.CSS_NAMESPACE}__progress-bar--${type}`,\n    {\n      [`${DEFAULT.CSS_NAMESPACE}__progress-bar--rtl`]: rtl\n    }\n  ];\n  const classNames = isFn(className)\n    ? className({\n        rtl,\n        type,\n        defaultClassName: cx(...defaultClassArr)\n      })\n    : cx(...[...defaultClassArr, className]);\n\n  // 🧐 controlledProgress is derived from progress\n  // so if controlledProgress is set\n  // it means that this is also the case for progress\n  const animationEvent = {\n    [controlledProgress && progress! >= 1\n      ? 'onTransitionEnd'\n      : 'onAnimationEnd']:\n      controlledProgress && progress! < 1\n        ? null\n        : () => {\n            isIn && closeToast();\n          }\n  };\n\n  return <div className={classNames} style={style} {...animationEvent} />;\n}\n\nProgressBar.defaultProps = {\n  type: TYPE.DEFAULT,\n  hide: false\n};\n","import * as React from 'react';\nimport cx from 'clsx';\n\nimport { ProgressBar } from './ProgressBar';\nimport { ToastProps } from '../types';\nimport { DEFAULT, isFn } from '../utils';\nimport { useToast } from '../hooks';\n\nexport const Toast: React.FC<ToastProps> = props => {\n  const {\n    isRunning,\n    preventExitTransition,\n    toastRef,\n    eventHandlers\n  } = useToast(props);\n  const {\n    closeButton,\n    children,\n    autoClose,\n    onClick,\n    type,\n    hideProgressBar,\n    closeToast,\n    transition: Transition,\n    position,\n    className,\n    style,\n    bodyClassName,\n    bodyStyle,\n    progressClassName,\n    progressStyle,\n    updateId,\n    role,\n    progress,\n    rtl,\n    toastId,\n    deleteToast\n  } = props;\n  const defaultClassArr = [\n    `${DEFAULT.CSS_NAMESPACE}__toast`,\n    `${DEFAULT.CSS_NAMESPACE}__toast--${type}`,\n    {\n      [`${DEFAULT.CSS_NAMESPACE}__toast--rtl`]: rtl\n    }\n  ];\n  const cssClasses = isFn(className)\n    ? className({\n        rtl,\n        position,\n        type,\n        defaultClassName: cx(...defaultClassArr)\n      })\n    : cx(...[...defaultClassArr, className]);\n  const controlledProgress = !!progress;\n\n  function renderCloseButton(closeButton: any) {\n    if (!closeButton) return;\n\n    const props = { closeToast, type };\n    if (isFn(closeButton)) return closeButton(props);\n    if (React.isValidElement(closeButton))\n      return React.cloneElement(closeButton, props);\n  }\n\n  return (\n    <Transition\n      in={props.in!}\n      appear\n      done={deleteToast}\n      position={position}\n      preventExitTransition={preventExitTransition}\n      nodeRef={toastRef}\n    >\n      <div\n        id={toastId as string}\n        onClick={onClick}\n        className={cssClasses || undefined}\n        {...eventHandlers}\n        style={style}\n        ref={toastRef}\n      >\n        <div\n          {...(props.in && { role: role })}\n          className={\n            isFn(bodyClassName)\n              ? bodyClassName({ type })\n              : cx(`${DEFAULT.CSS_NAMESPACE}__toast-body`, bodyClassName)\n          }\n          style={bodyStyle}\n        >\n          {children}\n        </div>\n        {renderCloseButton(closeButton)}\n        {(autoClose || controlledProgress) && (\n          <ProgressBar\n            {...(updateId && !controlledProgress\n              ? { key: `pb-${updateId}` }\n              : {})}\n            rtl={rtl}\n            delay={autoClose as number}\n            isRunning={isRunning}\n            isIn={props.in}\n            closeToast={closeToast}\n            hide={hideProgressBar}\n            type={type}\n            style={progressStyle}\n            className={progressClassName}\n            controlledProgress={controlledProgress}\n            progress={progress}\n          />\n        )}\n      </div>\n    </Transition>\n  );\n};\n","import { DEFAULT, cssTransition } from '../utils';\n\nconst Bounce = cssTransition({\n  enter: `${DEFAULT.CSS_NAMESPACE}__bounce-enter`,\n  exit: `${DEFAULT.CSS_NAMESPACE}__bounce-exit`,\n  appendPosition: true\n});\n\nconst Slide = cssTransition({\n  enter: `${DEFAULT.CSS_NAMESPACE}__slide-enter`,\n  exit: `${DEFAULT.CSS_NAMESPACE}__slide-exit`,\n  duration: [450, 750],\n  appendPosition: true\n});\n\nconst Zoom = cssTransition({\n  enter: `${DEFAULT.CSS_NAMESPACE}__zoom-enter`,\n  exit: `${DEFAULT.CSS_NAMESPACE}__zoom-exit`\n});\n\nconst Flip = cssTransition({\n  enter: `${DEFAULT.CSS_NAMESPACE}__flip-enter`,\n  exit: `${DEFAULT.CSS_NAMESPACE}__flip-exit`\n});\n\nexport { Bounce, Slide, Zoom, Flip };\n","import * as React from 'react';\nimport { ToastProps } from '../types';\ntype ToastPositionerProps = Pick<ToastProps, 'style' | 'in'> & {\n  className?: string;\n};\n\nexport const ToastPositioner: React.FC<ToastPositionerProps> = ({\n  children,\n  className,\n  style,\n  ...rest\n}) => {\n  // Monkey patch react-transition-group\n  // As exit transition is broken with strict mode\n  delete rest.in;\n\n  return (\n    <div className={className} style={style}>\n      {React.Children.map(children, child =>\n        React.cloneElement(child as React.ReactElement<any>, rest)\n      )}\n    </div>\n  );\n};\n","import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport cx from 'clsx';\n\nimport { Toast } from './Toast';\nimport { CloseButton } from './CloseButton';\nimport { Bounce } from './Transitions';\nimport {\n  POSITION,\n  DEFAULT,\n  parseClassName,\n  objectValues,\n  isFn\n} from '../utils';\nimport { useToastContainer } from '../hooks';\nimport { ToastContainerProps, ToastPosition } from '../types';\nimport { ToastPositioner } from './ToastPositioner';\n\nexport const ToastContainer: React.FC<ToastContainerProps> = props => {\n  const { getToastToRender, containerRef, isToastActive } = useToastContainer(\n    props\n  );\n  const { className, style, rtl, containerId } = props;\n\n  return (\n    <div\n      ref={containerRef}\n      className={DEFAULT.CSS_NAMESPACE as string}\n      id={containerId as string}\n    >\n      {getToastToRender((position, toastList) => {\n        const swag = {\n          className: isFn(className)\n            ? className({\n                position,\n                rtl,\n                defaultClassName: cx(\n                  `${DEFAULT.CSS_NAMESPACE}__toast-container`,\n                  `${DEFAULT.CSS_NAMESPACE}__toast-container--${position}`,\n                  { [`${DEFAULT.CSS_NAMESPACE}__toast-container--rtl`]: rtl }\n                )\n              })\n            : cx(\n                `${DEFAULT.CSS_NAMESPACE}__toast-container`,\n                `${DEFAULT.CSS_NAMESPACE}__toast-container--${position}`,\n                { [`${DEFAULT.CSS_NAMESPACE}__toast-container--rtl`]: rtl },\n                parseClassName(className)\n              ),\n          style:\n            toastList.length === 0\n              ? { ...style, pointerEvents: 'none' }\n              : { ...style }\n        } as any;\n        return (\n          <ToastPositioner {...swag} key={`container-${position}`}>\n            {toastList.map(({ content, props: toastProps }) => {\n              return (\n                <Toast\n                  {...toastProps}\n                  in={isToastActive(toastProps.toastId)}\n                  key={`toast-${toastProps.key}`}\n                  closeButton={\n                    toastProps.closeButton === true\n                      ? CloseButton\n                      : toastProps.closeButton\n                  }\n                >\n                  {content}\n                </Toast>\n              );\n            })}\n          </ToastPositioner>\n        );\n      })}\n    </div>\n  );\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  // @ts-ignore\n  ToastContainer.propTypes = {\n    // @ts-ignore\n    position: PropTypes.oneOf(objectValues(POSITION)),\n\n    // @ts-ignore\n    autoClose: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\n\n    // @ts-ignore\n    closeButton: PropTypes.oneOfType([\n      PropTypes.node,\n      PropTypes.bool,\n      PropTypes.func\n    ]),\n    hideProgressBar: PropTypes.bool,\n    pauseOnHover: PropTypes.bool,\n    closeOnClick: PropTypes.bool,\n    newestOnTop: PropTypes.bool,\n    className: PropTypes.any, //oneOfType([PropTypes.func, PropTypes.string]),\n    style: PropTypes.object,\n    toastClassName: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    bodyClassName: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    progressClassName: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    progressStyle: PropTypes.object,\n    transition: PropTypes.func,\n    rtl: PropTypes.bool,\n    draggable: PropTypes.bool,\n    draggablePercent: PropTypes.number,\n    pauseOnFocusLoss: PropTypes.bool,\n    enableMultiContainer: PropTypes.bool,\n    containerId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    role: PropTypes.string,\n    onClick: PropTypes.func\n  };\n}\n\nToastContainer.defaultProps = {\n  position: POSITION.TOP_RIGHT as ToastPosition,\n  transition: Bounce,\n  rtl: false,\n  autoClose: 5000,\n  hideProgressBar: false,\n  closeButton: CloseButton,\n  pauseOnHover: true,\n  pauseOnFocusLoss: true,\n  closeOnClick: true,\n  newestOnTop: false,\n  draggable: true,\n  draggablePercent: 80,\n  role: 'alert'\n};\n","import * as React from 'react';\nimport { render } from 'react-dom';\n\nimport { POSITION, TYPE, canUseDom, isStr, isNum, isFn } from '../utils';\nimport { eventManager, OnChangeCallback, Event } from './eventManager';\nimport {\n  ToastContent,\n  ToastOptions,\n  ToastProps,\n  Id,\n  ToastContainerProps,\n  UpdateOptions,\n  ClearWaitingQueueParams,\n  NotValidatedToastProps\n} from '../types';\nimport { ContainerInstance } from 'hooks';\nimport { ToastContainer } from '../components';\n\ninterface EnqueuedToast {\n  content: ToastContent;\n  options: NotValidatedToastProps;\n}\n\nlet containers = new Map<ContainerInstance | Id, ContainerInstance>();\nlet latestInstance: ContainerInstance | Id;\nlet containerDomNode: HTMLElement;\nlet containerConfig: ToastContainerProps;\nlet queue: EnqueuedToast[] = [];\nlet lazy = false;\n\n/**\n * Check whether any container is currently mounted in the DOM\n */\nfunction isAnyContainerMounted() {\n  return containers.size > 0;\n}\n\n/**\n * Get the container by id. Returns the last container declared when no id is given.\n */\nfunction getContainer(containerId?: Id) {\n  if (!isAnyContainerMounted()) return null;\n  return containers.get(!containerId ? latestInstance : containerId);\n}\n\n/**\n * Get the toast by id, given it's in the DOM, otherwise returns null\n */\nfunction getToast(toastId: Id, { containerId }: ToastOptions) {\n  const container = getContainer(containerId);\n  if (!container) return null;\n\n  return container.getToast(toastId);\n}\n\n/**\n * Generate a random toastId\n */\nfunction generateToastId() {\n  return (Math.random().toString(36) + Date.now().toString(36)).substr(2, 10);\n}\n\n/**\n * Generate a toastId or use the one provided\n */\nfunction getToastId(options?: ToastOptions) {\n  if (options && (isStr(options.toastId) || isNum(options.toastId))) {\n    return options.toastId;\n  }\n\n  return generateToastId();\n}\n\n/**\n * If the container is not mounted, the toast is enqueued and\n * the container lazy mounted\n */\nfunction dispatchToast(\n  content: ToastContent,\n  options: NotValidatedToastProps\n): Id {\n  if (isAnyContainerMounted()) {\n    eventManager.emit(Event.Show, content, options);\n  } else {\n    queue.push({ content, options });\n    if (lazy && canUseDom) {\n      lazy = false;\n      containerDomNode = document.createElement('div');\n      document.body.appendChild(containerDomNode);\n      render(<ToastContainer {...containerConfig} />, containerDomNode);\n    }\n  }\n\n  return options.toastId;\n}\n\n/**\n * Merge provided options with the defaults settings and generate the toastId\n */\nfunction mergeOptions(type: string, options?: ToastOptions) {\n  return {\n    ...options,\n    type: (options && options.type) || type,\n    toastId: getToastId(options)\n  } as NotValidatedToastProps;\n}\n\nconst toast = (content: ToastContent, options?: ToastOptions) =>\n  dispatchToast(content, mergeOptions(TYPE.DEFAULT, options));\n\ntoast.success = (content: ToastContent, options?: ToastOptions) =>\n  dispatchToast(content, mergeOptions(TYPE.SUCCESS, options));\n\ntoast.info = (content: ToastContent, options?: ToastOptions) =>\n  dispatchToast(content, mergeOptions(TYPE.INFO, options));\n\ntoast.error = (content: ToastContent, options?: ToastOptions) =>\n  dispatchToast(content, mergeOptions(TYPE.ERROR, options));\n\ntoast.warning = (content: ToastContent, options?: ToastOptions) =>\n  dispatchToast(content, mergeOptions(TYPE.WARNING, options));\n\ntoast.dark = (content: ToastContent, options?: ToastOptions) =>\n  dispatchToast(content, mergeOptions(TYPE.DARK, options));\n\n/**\n * Maybe I should remove warning in favor of warn, I don't know\n */\ntoast.warn = toast.warning;\n\n/**\n * Remove toast programmaticaly\n */\ntoast.dismiss = (id?: Id) =>\n  isAnyContainerMounted() && eventManager.emit(Event.Clear, id);\n\n/**\n * Clear waiting queue when limit is used\n */\ntoast.clearWaitingQueue = (params: ClearWaitingQueueParams = {}) =>\n  isAnyContainerMounted() && eventManager.emit(Event.ClearWaitingQueue, params);\n\n/**\n * return true if one container is displaying the toast\n */\ntoast.isActive = (id: Id) => {\n  let isToastActive = false;\n\n  containers.forEach(container => {\n    if (container.isToastActive && container.isToastActive(id)) {\n      isToastActive = true;\n    }\n  });\n\n  return isToastActive;\n};\n\ntoast.update = (toastId: Id, options: UpdateOptions = {}) => {\n  // if you call toast and toast.update directly nothing will be displayed\n  // this is why I defered the update\n  setTimeout(() => {\n    const toast = getToast(toastId, options as ToastOptions);\n    if (toast) {\n      const { props: oldOptions, content: oldContent } = toast;\n\n      const nextOptions = {\n        ...oldOptions,\n        ...options,\n        toastId: options.toastId || toastId,\n        updateId: generateToastId()\n      } as ToastProps & UpdateOptions;\n\n      if (nextOptions.toastId !== toastId) nextOptions.staleId = toastId;\n\n      const content =\n        typeof nextOptions.render !== 'undefined'\n          ? nextOptions.render\n          : oldContent;\n      delete nextOptions.render;\n\n      dispatchToast(content, nextOptions);\n    }\n  }, 0);\n};\n\n/**\n * Used for controlled progress bar.\n */\ntoast.done = (id: Id) => {\n  toast.update(id, {\n    progress: 1\n  });\n};\n\n/**\n * Track changes. The callback get the number of toast displayed\n *\n */\ntoast.onChange = (callback: OnChangeCallback) => {\n  if (isFn(callback)) {\n    eventManager.on(Event.Change, callback);\n  }\n  return () => {\n    isFn(callback) && eventManager.off(Event.Change, callback);\n  };\n};\n\n/**\n * Configure the ToastContainer when lazy mounted\n */\ntoast.configure = (config: ToastContainerProps = {}) => {\n  lazy = true;\n  containerConfig = config;\n};\n\ntoast.POSITION = POSITION;\ntoast.TYPE = TYPE;\n\n/**\n * Wait until the ToastContainer is mounted to dispatch the toast\n * and attach isActive method\n */\neventManager\n  .on(Event.DidMount, (containerInstance: ContainerInstance) => {\n    latestInstance = containerInstance.containerId || containerInstance;\n    containers.set(latestInstance, containerInstance);\n\n    queue.forEach(item => {\n      eventManager.emit(Event.Show, item.content, item.options);\n    });\n\n    queue = [];\n  })\n  .on(Event.WillUnmount, (containerInstance: ContainerInstance) => {\n    containers.delete(containerInstance.containerId || containerInstance);\n\n    if (containers.size === 0) {\n      eventManager\n        .off(Event.Show)\n        .off(Event.Clear)\n        .off(Event.ClearWaitingQueue);\n    }\n\n    if (canUseDom && containerDomNode) {\n      document.body.removeChild(containerDomNode);\n    }\n  });\n\nexport { toast };\n"],"sourceRoot":""}